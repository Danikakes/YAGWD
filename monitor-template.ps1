<#
.SYNOPSIS
    <<APP_NAME>> Monitor and Crash Reporter
.DESCRIPTION
    Auto-generated monitor with embedded configuration
    DO NOT EDIT THIS FILE - Edit build-config.ini and rebuild instead
#>

# Enable TLS 1.2
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# ============================================================
# EMBEDDED CONFIGURATION (Auto-injected from build-config.ini)
# ============================================================

$APP_NAME = "<<APP_NAME>>"
$DEFAULT_EXE_PATH = "<<EXE_PATH>>"
$DEFAULT_LOG_DIRECTORY = "<<LOG_DIRECTORY>>"
$QUIET_TIMEOUT_SECONDS = <<QUIET_TIMEOUT_SECONDS>>
$SHOW_LOG_LOCATION = $<<SHOW_LOG_LOCATION>>

# Encrypted Dropbox token (auto-injected)
$ENCRYPTED_TOKEN = "<<ENCRYPTED_TOKEN>>"

# Encryption key
$ENCRYPTION_KEY = @(0x1F, 0x3A, 0x5C, 0x7E, 0x9B, 0xAD, 0xCF, 0xE1,
                    0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01,
                    0x13, 0x24, 0x35, 0x46, 0x57, 0x68, 0x79, 0x8A,
                    0x9B, 0xAC, 0xBD, 0xCE, 0xDF, 0xE0, 0xF1, 0x02)

# ============================================================
# FUNCTIONS
# ============================================================

function Decrypt-Token {
    param([string]$EncryptedToken, [byte[]]$Key)
    
    try {
        if ($EncryptedToken -eq "ENCRYPTED_TOKEN_PLACEHOLDER" -or [string]::IsNullOrEmpty($EncryptedToken)) {
            return ""
        }
        
        $encryptedBytes = [Convert]::FromBase64String($EncryptedToken)
        $aes = [System.Security.Cryptography.Aes]::Create()
        $aes.Key = $Key
        
        $iv = $encryptedBytes[0..15]
        $aes.IV = $iv
        
        $ciphertext = $encryptedBytes[16..($encryptedBytes.Length - 1)]
        $decryptor = $aes.CreateDecryptor()
        $decryptedBytes = $decryptor.TransformFinalBlock($ciphertext, 0, $ciphertext.Length)
        
        $token = [System.Text.Encoding]::UTF8.GetString($decryptedBytes)
        
        $aes.Dispose()
        return $token
    }
    catch {
        Write-Host "Warning: Failed to decrypt token: $_" -ForegroundColor Yellow
        return ""
    }
}

function Upload-ToDropbox {
    param(
        [string]$FilePath,
        [string]$AccessToken
    )
    
    if ([string]::IsNullOrEmpty($AccessToken)) {
        Write-Host "  Crash reporting disabled (no token configured)" -ForegroundColor Yellow
        return $false
    }
    
    if (-not (Test-Path $FilePath)) {
        Write-Host "  File not found: $FilePath" -ForegroundColor Red
        return $false
    }
    
    try {
        $fileName = Split-Path $FilePath -Leaf
        $dropboxPath = "/crash_reports/$fileName"
        
        # Fixed JSON format to prevent 400 errors
        $apiArg = "{`"path`":`"$dropboxPath`",`"mode`":`"add`",`"autorename`":true,`"mute`":false}"
        
        Write-Host "  Uploading crash report..." -ForegroundColor Cyan
        
        $headers = @{
            "Authorization" = "Bearer $AccessToken"
            "Dropbox-API-Arg" = $apiArg
            "Content-Type" = "application/octet-stream"
        }
        
        $fileBytes = [System.IO.File]::ReadAllBytes($FilePath)
        
        $response = Invoke-RestMethod `
            -Uri "https://content.dropboxapi.com/2/files/upload" `
            -Method Post `
            -Headers $headers `
            -Body $fileBytes `
            -TimeoutSec 30 `
            -ErrorAction Stop
        
        Write-Host "  ✓ Upload successful!" -ForegroundColor Green
        return $true
        
    } catch {
        Write-Host "  ✗ Upload failed: $($_.Exception.Message)" -ForegroundColor Red
        
        if ($_.Exception.Response) {
            $statusCode = $_.Exception.Response.StatusCode.value__
            Write-Host "  Status: $statusCode" -ForegroundColor Red
            
            switch ($statusCode) {
                400 { Write-Host "  → Bad Request (please report this bug)" -ForegroundColor Yellow }
                401 { Write-Host "  → Token expired (developer needs to update)" -ForegroundColor Yellow }
                403 { Write-Host "  → Permission denied" -ForegroundColor Yellow }
                429 { Write-Host "  → Rate limited, try again later" -ForegroundColor Yellow }
            }
        }
        
        return $false
    }
}

# ============================================================
# MAIN EXECUTION
# ============================================================

# Decrypt the token
$DropboxAccessToken = Decrypt-Token -EncryptedToken $ENCRYPTED_TOKEN -Key $ENCRYPTION_KEY

# Use default exe path
$ExePath = $DEFAULT_EXE_PATH
$LogDirectory = $DEFAULT_LOG_DIRECTORY

# Create log directory
if (-not (Test-Path $LogDirectory)) {
    New-Item -ItemType Directory -Path $LogDirectory -Force | Out-Null
}

# Generate log files
$timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
$logFile = Join-Path $LogDirectory "$APP_NAME`_log_$timestamp.txt"
$crashLogFile = Join-Path $LogDirectory "$APP_NAME`_crash_$timestamp.txt"

# Verify executable exists
if (-not (Test-Path $ExePath)) {
    Write-Host "`nError: Could not find $APP_NAME executable!" -ForegroundColor Red
    Write-Host "Expected location: $ExePath" -ForegroundColor Yellow
    Write-Host "`nPlease ensure this monitor is placed in the correct directory." -ForegroundColor Yellow
    Read-Host "`nPress Enter to exit"
    exit 1
}

$giturl = "https://github.com/Danikakes/YAGWD"

# Display startup banner
Write-Host "`n============================================================" -ForegroundColor Cyan
Write-Host "$APP_NAME MONITOR" -ForegroundColor Cyan
Write-Host "============================================================" -ForegroundColor Cyan
Write-Host "Help Make YAGWD Better! Check out $giturl"
Write-Host "============================================================" -ForegroundColor Cyan
Write-Host "Application: $ExePath" -ForegroundColor White
Write-Host "Log File: $logFile" -ForegroundColor White
Write-Host "Crash Reporting: $(if ([string]::IsNullOrEmpty($DropboxAccessToken)) { 'Disabled' } else { 'Enabled' })" -ForegroundColor White
Write-Host "============================================================`n" -ForegroundColor Cyan

# Variables for tracking console activity
$script:lastOutputTime = [DateTime]::Now
$script:outputReceived = $false
$script:isQuiet = $false

# Start the process
try {
    $processStartInfo = New-Object System.Diagnostics.ProcessStartInfo
    $processStartInfo.FileName = $ExePath
    $processStartInfo.RedirectStandardOutput = $true
    $processStartInfo.RedirectStandardError = $true
    $processStartInfo.UseShellExecute = $false
    $processStartInfo.CreateNoWindow = $false
    
    $process = New-Object System.Diagnostics.Process
    $process.StartInfo = $processStartInfo
    
    # Output builders
    $outputBuilder = New-Object System.Text.StringBuilder
    $errorBuilder = New-Object System.Text.StringBuilder
    
    $outputHandler = {
        if (-not [string]::IsNullOrEmpty($EventArgs.Data)) {
            $line = $EventArgs.Data
            Write-Host $line
            $outputBuilder.AppendLine($line) | Out-Null
            Add-Content -Path $logFile -Value $line
            
            # Track output timing
            $script:lastOutputTime = [DateTime]::Now
            $script:outputReceived = $true
        }
    }
    
    $errorHandler = {
        if (-not [string]::IsNullOrEmpty($EventArgs.Data)) {
            $line = "[ERROR] $($EventArgs.Data)"
            Write-Host $line -ForegroundColor Red
            $errorBuilder.AppendLine($line) | Out-Null
            Add-Content -Path $logFile -Value $line
            
            # Track output timing
            $script:lastOutputTime = [DateTime]::Now
            $script:outputReceived = $true
        }
    }
    
    Register-ObjectEvent -InputObject $process -EventName OutputDataReceived -Action $outputHandler | Out-Null
    Register-ObjectEvent -InputObject $process -EventName ErrorDataReceived -Action $errorHandler | Out-Null
    
    # Start the process
    $process.Start() | Out-Null
    $process.BeginOutputReadLine()
    $process.BeginErrorReadLine()
    
    # Wait for exit
    $process.WaitForExit()
    
    # Get exit code
    $exitCode = $process.ExitCode
    
    # Wait for console to become quiet if crashed
    if ($exitCode -ne 0) {
        Write-Host "`n[Monitoring console output for final logs...]" -ForegroundColor Yellow
        
        $maxWaitTime = 30  # Maximum 30 seconds total
        $waitStartTime = [DateTime]::Now
        $script:lastOutputTime = [DateTime]::Now
        
        while ($true) {
            $timeSinceLastOutput = ([DateTime]::Now - $script:lastOutputTime).TotalSeconds
            $totalWaitTime = ([DateTime]::Now - $waitStartTime).TotalSeconds
            
            # Console has been quiet for the required time
            if ($timeSinceLastOutput -ge $QUIET_TIMEOUT_SECONDS) {
                Write-Host "[Console quiet for $QUIET_TIMEOUT_SECONDS seconds - logs captured]" -ForegroundColor Green
                break
            }
            
            # Maximum wait time exceeded
            if ($totalWaitTime -ge $maxWaitTime) {
                Write-Host "[Maximum wait time ($maxWaitTime seconds) reached - proceeding]" -ForegroundColor Yellow
                break
            }
            
            # Check every 100ms
            Start-Sleep -Milliseconds 100
        }
    }
    
    Write-Host "`n============================================================" -ForegroundColor Cyan
    Write-Host "Application exited with code: $exitCode" -ForegroundColor Cyan
    Write-Host "============================================================" -ForegroundColor Cyan
    
    # Handle crash
    if ($exitCode -ne 0) {
        # Create crash report
        $crashReport = @"
============================================================
$APP_NAME CRASH REPORT
============================================================
Application: $ExePath
Timestamp: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")
Exit Code: $exitCode
Computer: $env:COMPUTERNAME
User: $env:USERNAME
OS: $(Get-WmiObject -Class Win32_OperatingSystem | Select-Object -ExpandProperty Caption)
============================================================

STDOUT OUTPUT:
$($outputBuilder.ToString())

============================================================
STDERR OUTPUT:
$($errorBuilder.ToString())

============================================================
"@
        
        Set-Content -Path $crashLogFile -Value $crashReport
        
        Write-Host "`n⚠ $APP_NAME CRASHED ⚠" -ForegroundColor Red
        Write-Host "Crash report saved to: $crashLogFile`n" -ForegroundColor Yellow
        
        # Prompt for submission
        $response = Read-Host "Would you like to submit this crash report to help improve $APP_NAME`? (Y/N)"
        
        if ($response -eq 'Y' -or $response -eq 'y') {
            Write-Host "`nSubmitting crash report..." -ForegroundColor Cyan
            $uploaded = Upload-ToDropbox -FilePath $crashLogFile -AccessToken $DropboxAccessToken
            
            if ($uploaded) {
                Write-Host "`nThank you for helping improve $APP_NAME!" -ForegroundColor Green
            } else {
                Write-Host "`nCrash report saved locally but could not be uploaded." -ForegroundColor Yellow
            }
        } else {
            Write-Host "`nCrash report saved locally but not submitted." -ForegroundColor Yellow
        }
        
        if ($SHOW_LOG_LOCATION) {
            Write-Host "`nFull log location: $logFile" -ForegroundColor Cyan
        }
    } else {
        Write-Host "`n✓ $APP_NAME exited normally." -ForegroundColor Green
    }
    
    # Cleanup
    $process.Dispose()
    Get-EventSubscriber | Unregister-Event
    
} catch {
    Write-Host "`nError running $APP_NAME`: $_" -ForegroundColor Red
    Read-Host "Press Enter to exit"
    exit 1
}

## Uncomment to propt user to close
# Read-Host "`nPress Enter to exit"
